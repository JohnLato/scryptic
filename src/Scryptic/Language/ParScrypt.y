-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module Scryptic.Language.ParScrypt where
import Scryptic.Language.AbsScrypt
import Scryptic.Language.LexScrypt
import Scryptic.Language.ErrM

}

%name pScrypt Scrypt
%name pBlock Block
%name pStmt Stmt

-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype { Token }

%token 
 '.' { PT _ (TS _ 1) }
 ';' { PT _ (TS _ 2) }
 'opt' { PT _ (TS _ 3) }
 'sleep' { PT _ (TS _ 4) }
 'sync' { PT _ (TS _ 5) }
 'title' { PT _ (TS _ 6) }
 'unwatch' { PT _ (TS _ 7) }
 'wait' { PT _ (TS _ 8) }
 'watch' { PT _ (TS _ 9) }
 'write' { PT _ (TS _ 10) }
 '{' { PT _ (TS _ 11) }
 '}' { PT _ (TS _ 12) }

L_ident  { PT _ (TV $$) }
L_quoted { PT _ (TL $$) }
L_integ  { PT _ (TI $$) }
L_doubl  { PT _ (TD $$) }
L_err    { _ }


%%

Ident   :: { Ident }   : L_ident  { Ident $1 }
String  :: { String }  : L_quoted {  $1 }
Integer :: { Integer } : L_integ  { (read ( $1)) :: Integer }
Double  :: { Double }  : L_doubl  { (read ( $1)) :: Double }

Scrypt :: { Scrypt }
Scrypt : Block { OneBlock $1 } 
  | ListBlock { MultiBlock $1 }


ListBlock :: { [Block] }
ListBlock : '{' Block '}' { (:[]) $2 } 
  | '{' Block '}' ListBlock { (:) $2 $4 }


Block :: { Block }
Block : ListBlockOpt ListStmt { Block (reverse $1) (reverse $2) } 


ListBlockOpt :: { [BlockOpt] }
ListBlockOpt : {- empty -} { [] } 
  | ListBlockOpt BlockOpt ';' { flip (:) $1 $2 }


BlockOpt :: { BlockOpt }
BlockOpt : 'title' Ident { TitleOpt $2 } 


ListStmt :: { [Stmt] }
ListStmt : {- empty -} { [] } 
  | ListStmt Stmt ';' { flip (:) $1 $2 }


Stmt :: { Stmt }
Stmt : 'wait' SKey { Wait $2 } 
  | 'write' SKey SOptVal { Write $2 $3 }
  | 'write' SKey SOptVal 'sync' SKey { WriteSync $2 $3 $5 }
  | 'watch' SKey { Watch $2 }
  | 'unwatch' SKey { Unwatch $2 }
  | 'sleep' SNum { Sleep $2 }
  | 'opt' SKey Ident { SetOpt $2 $3 }


SKey :: { SKey }
SKey : ListNameQual Ident { SKey (reverse $1) $2 } 


ListNameQual :: { [NameQual] }
ListNameQual : {- empty -} { [] } 
  | ListNameQual NameQual '.' { flip (:) $1 $2 }


NameQual :: { NameQual }
NameQual : Ident { NameQual $1 } 


SOptVal :: { SOptVal }
SOptVal : SNum { SOptNum $1 } 
  | String { SOptStr $1 }
  | {- empty -} { SOptNone }


SNum :: { SNum }
SNum : Integer { IntNum $1 } 
  | Double { DubNum $1 }



{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ 
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    _ -> " before " ++ unwords (map (id . prToken) (take 4 ts))

myLexer = tokens
}

