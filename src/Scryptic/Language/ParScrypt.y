-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module Scryptic.Language.ParScrypt where
import Scryptic.Language.AbsScrypt
import Scryptic.Language.LexScrypt
import Scryptic.Language.ErrM

}

%name pScrypt Scrypt
%name pBlock Block
%name pStmt Stmt

-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype { Token }

%token 
 '&&' { PT _ (TS _ 1) }
 '(' { PT _ (TS _ 2) }
 ')' { PT _ (TS _ 3) }
 '.' { PT _ (TS _ 4) }
 '/=' { PT _ (TS _ 5) }
 ';' { PT _ (TS _ 6) }
 '<' { PT _ (TS _ 7) }
 '<=' { PT _ (TS _ 8) }
 '==' { PT _ (TS _ 9) }
 '>' { PT _ (TS _ 10) }
 '>=' { PT _ (TS _ 11) }
 'opt' { PT _ (TS _ 12) }
 'sleep' { PT _ (TS _ 13) }
 'sync' { PT _ (TS _ 14) }
 'title' { PT _ (TS _ 15) }
 'unwatch' { PT _ (TS _ 16) }
 'wait' { PT _ (TS _ 17) }
 'watch' { PT _ (TS _ 18) }
 'write' { PT _ (TS _ 19) }
 '{' { PT _ (TS _ 20) }
 '||' { PT _ (TS _ 21) }
 '}' { PT _ (TS _ 22) }

L_ident  { PT _ (TV $$) }
L_quoted { PT _ (TL $$) }
L_integ  { PT _ (TI $$) }
L_doubl  { PT _ (TD $$) }
L_err    { _ }


%%

Ident   :: { Ident }   : L_ident  { Ident $1 }
String  :: { String }  : L_quoted {  $1 }
Integer :: { Integer } : L_integ  { (read ( $1)) :: Integer }
Double  :: { Double }  : L_doubl  { (read ( $1)) :: Double }

Scrypt :: { Scrypt }
Scrypt : Block { OneBlock $1 } 
  | ListBlock { MultiBlock $1 }


ListBlock :: { [Block] }
ListBlock : '{' Block '}' { (:[]) $2 } 
  | '{' Block '}' ListBlock { (:) $2 $4 }


Block :: { Block }
Block : ListBlockOpt ListStmt { Block (reverse $1) (reverse $2) } 


ListBlockOpt :: { [BlockOpt] }
ListBlockOpt : {- empty -} { [] } 
  | ListBlockOpt BlockOpt ';' { flip (:) $1 $2 }


BlockOpt :: { BlockOpt }
BlockOpt : 'title' Ident { TitleOpt $2 } 


ListStmt :: { [Stmt] }
ListStmt : {- empty -} { [] } 
  | ListStmt Stmt ';' { flip (:) $1 $2 }


Stmt :: { Stmt }
Stmt : 'wait' Expr { Wait $2 } 
  | 'write' SKey SOptVal { Write $2 $3 }
  | 'write' SKey SOptVal 'sync' Expr { WriteSync $2 $3 $5 }
  | 'watch' SKey { Watch $2 }
  | 'unwatch' SKey { Unwatch $2 }
  | 'sleep' SNum { Sleep $2 }
  | 'opt' SKey Ident { SetOpt $2 $3 }


Expr :: { Expr }
Expr : Expr '||' Expr1 { OrExpr $1 $3 } 
  | Expr1 { $1 }


Expr1 :: { Expr }
Expr1 : Expr1 '&&' Expr2 { AndExpr $1 $3 } 
  | Expr2 { $1 }


Expr2 :: { Expr }
Expr2 : Expr5 CmpOp Expr4 { CmpExpr $1 $2 $3 } 
  | Expr3 { $1 }


Expr3 :: { Expr }
Expr3 : SVal CmpOp SKey CmpOp SVal { RCmpExpr $1 $2 $3 $4 $5 } 
  | Expr4 { $1 }


Expr4 :: { Expr }
Expr4 : SVal { RConstExpr $1 } 
  | Expr5 { $1 }


Expr5 :: { Expr }
Expr5 : SKey { KeyExpr $1 } 
  | '(' Expr ')' { $2 }


SKey :: { SKey }
SKey : ListNameQual Ident { SKey (reverse $1) $2 } 


ListNameQual :: { [NameQual] }
ListNameQual : {- empty -} { [] } 
  | ListNameQual NameQual '.' { flip (:) $1 $2 }


NameQual :: { NameQual }
NameQual : Ident { NameQual $1 } 


SOptVal :: { SOptVal }
SOptVal : SVal { SOptVal $1 } 
  | {- empty -} { SOptNone }


SVal :: { SVal }
SVal : SNum { SValNum $1 } 
  | String { SValStr $1 }


SNum :: { SNum }
SNum : Integer { IntNum $1 } 
  | Double { DubNum $1 }


CmpOp :: { CmpOp }
CmpOp : '==' { EqOp } 
  | '/=' { NEqOp }
  | '<' { LtOp }
  | '>' { GtOp }
  | '<=' { LEqOp }
  | '>=' { GEqOp }



{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ 
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    _ -> " before " ++ unwords (map (id . prToken) (take 4 ts))

myLexer = tokens
}

